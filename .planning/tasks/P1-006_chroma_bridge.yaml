# Task: Implement ChromaBridge
id: P1-006
phase: 1
title: "Implement ChromaBridge for vector search"
status: pending
priority: medium
estimated_lines: 100

# Description
description: |
  Implement ChromaBridge that wraps ChromaDB for semantic search.
  This enables similarity-based memory retrieval using embeddings.

  ChromaDB will:
  - Store memory embeddings
  - Enable semantic search
  - Support filtering by type

# Output
output_file: "msp/storage/chroma_bridge.py"

# Specification
spec: |
  ```python
  """ChromaDB Bridge - Vector search for memories."""

  from typing import List, Dict, Any, Optional
  import chromadb
  from chromadb.config import Settings

  from msp.schema.episodic import EpisodicMemory
  from msp.schema.semantic import SemanticMemory
  from msp.schema.sensory import SensoryMemory


  class ChromaBridge:
      """
      Vector database bridge using ChromaDB.

      Provides semantic search capabilities for memories.
      Uses ChromaDB's built-in embedding function.

      Attributes:
          _client: ChromaDB client
          _collection: Memory collection
      """

      def __init__(self, persist_directory: Optional[str] = None):
          """
          Initialize ChromaDB bridge.

          Args:
              persist_directory: Optional path for persistence.
                                 If None, uses in-memory storage.
          """
          if persist_directory:
              self._client = chromadb.PersistentClient(path=persist_directory)
          else:
              self._client = chromadb.Client()

          self._collection = self._client.get_or_create_collection(
              name="eva_memories",
              metadata={"hnsw:space": "cosine"}
          )

      def add_memory(self, memory_id: str, content: str,
                     memory_type: str, metadata: Dict[str, Any]) -> None:
          """
          Add a memory to the vector store.

          Args:
              memory_id: Unique ID for the memory
              content: Text content to embed
              memory_type: Type ('episodic', 'semantic', 'sensory')
              metadata: Additional metadata to store
          """
          self._collection.add(
              ids=[memory_id],
              documents=[content],
              metadatas=[{
                  "type": memory_type,
                  **metadata
              }]
          )

      def search(self, query: str, limit: int = 10,
                 memory_type: Optional[str] = None) -> List[Dict[str, Any]]:
          """
          Search for similar memories.

          Args:
              query: Search query text
              limit: Maximum results to return
              memory_type: Optional filter by type

          Returns:
              List of dicts with 'id', 'distance', 'metadata'
          """
          where_filter = {"type": memory_type} if memory_type else None

          results = self._collection.query(
              query_texts=[query],
              n_results=limit,
              where=where_filter
          )

          # Format results
          formatted = []
          if results['ids'] and results['ids'][0]:
              for i, mem_id in enumerate(results['ids'][0]):
                  formatted.append({
                      "id": mem_id,
                      "distance": results['distances'][0][i] if results['distances'] else 0,
                      "metadata": results['metadatas'][0][i] if results['metadatas'] else {}
                  })

          return formatted

      def delete_memory(self, memory_id: str) -> None:
          """
          Delete a memory from the vector store.

          Args:
              memory_id: ID of memory to delete
          """
          self._collection.delete(ids=[memory_id])

      def get_memory_ids(self, memory_type: Optional[str] = None) -> List[str]:
          """
          Get all memory IDs, optionally filtered by type.

          Args:
              memory_type: Optional filter by type

          Returns:
              List of memory IDs
          """
          where_filter = {"type": memory_type} if memory_type else None

          results = self._collection.get(
              where=where_filter,
              include=[]
          )

          return results['ids'] if results['ids'] else []

      def clear(self) -> None:
          """Clear all memories (for testing)."""
          # Delete and recreate collection
          self._client.delete_collection("eva_memories")
          self._collection = self._client.get_or_create_collection(
              name="eva_memories",
              metadata={"hnsw:space": "cosine"}
          )
  ```

# Acceptance Criteria
acceptance_criteria:
  - File exists at msp/storage/chroma_bridge.py
  - ChromaBridge wraps ChromaDB
  - add_memory() stores with embedding
  - search() returns similar memories
  - Can filter by memory type
  - clear() works for testing

# Dependencies
depends_on: [P1-005]
blocks: [P1-007]

# Notes
notes: |
  Requires: pip install chromadb
  ChromaDB uses sentence-transformers for embeddings by default.
